/*jslint indent: 4, maxerr: 50, white: true, node: true, stupid: true */
/*global array_diff, array_flip */

/**
 * @file This file contains small utilities specific to jsdoc3.github.com.
 * @author <a href="matthewkastor@gmail.com">Matthew Kastor</a>
 * @version 20121030
 * @requires fs
 * @requires path
 * @requires jsdoc3_commandlines
 * @requires Exists
 * @requires colors
 * @exports jsdocPaths
 * @exports jakeApiDirectories
 * @exports verifyJsdocPathsAndFiles
 * @exports generateMissingTagsArticles
 * @exports createRunJsdocCommand
 * @exports rebuildDescribeTags
 * @exports runJake
 */

'use strict';

var fs,
    path,
    jsdoc3_commandlines,
    Exists,
    exists,
    colors,
    jsdocPaths,
    jakeApiDirectories;
    
fs                 = require('fs');
path               = require('path');
jsdoc3_commandlines= require('jsdoc3_commandlines');
Exists             = require('Exists').Exists;
exists             = new Exists();
colors             = require('colors');
colors.setTheme(JSON.parse(fs.readFileSync('jake/confFiles/consoleColors.json', 'utf8')));


exists.on('error', function(err) {
    console.log(err.warn);
    process.exit(1);
});

/**
 * Verifies that the locations of jsdoc and the documentation project are
 *  known.
 * @function
 * @returns {Object} Returns an object containing the resolved paths to both
 *  projects, or an error will be emitted by one of the verifircation
 *  methods.
 */
function verifyJsdocPathsAndFiles() {
    var out, usage;
    
    out = {
        jsdocLocation     : process.argv[2] || path.resolve(process.cwd(), '../jsdoc'),
        jsdocDocsLocation : process.argv[3] || path.resolve(process.cwd(), '../jsdoc3.github.com')
    };
    
    usage  = 'usage: node ' + require.main.filename;
    usage += ' <jsdoc directory> <jsdoc docs project directory>';
    
    function showUsage() {
        console.log(usage.help);
    }
    
    exists.on('error', showUsage);
    
    exists.dirMustExist(out.jsdocLocation);
    exists.dirMustExist(out.jsdocDocsLocation);
    
    exists.fileMustExist(
        path.resolve(out.jsdocLocation, 'jsdoc.js')
    );
    exists.fileMustExist(
        path.resolve(out.jsdocDocsLocation, 'jakefile.js')
    );
    
    exists.removeListener('error', showUsage);
    
    return out;
}


/**
 * Generates missing article files and extended docs for
 * tags that have definitions but no articles.
 * @function
 */
function generateMissingTagsArticles() {
    console.log('Checking for missing tags articles'.info);
    var php,
        MustacheComb,
        mustachio,
        directory,
        tmp,
        api,
        art,
        test,
        mustacheTemplateParts,
        articleFile,
        extendedDoc;
        
    php         = require('phpjs').registerGlobals();
    MustacheComb= require('mustacheFunctions').MustacheComb;

    mustachio = new MustacheComb();

    directory = require('utilities').directory;

    function getFilenamePrefixTest(prefix) {
        return function test(file) {
            var out = false;
            if(file.indexOf(String(prefix)) === 0) {
                out = true;
            } else {
                out = false;
            }
            return out;
        };
    }

    api = {
        'dir' : 'Jake/API/describeTags',
        'list': []
    };
    art = {
        'dir'     : 'Jake/articles',
        'list'    : [],
        'missing' : {}
    };

    // get the lists of files to compare.
    test     = getFilenamePrefixTest('tags-');
    api.list = directory.filterList(api.dir, test);
    art.list = directory.filterList(art.dir, test);
    // remove file extension
    api.list = api.list.map(function(e){
        return e.replace(/\.html/, '');
    });
    // get the difference between the two
    art.missing = array_diff(api.list, art.list);
    // flip keys for values
    art.missing = array_flip(art.missing);
    
    mustacheTemplateParts = {};
    
    for(tmp in art.missing) {
        if(art.missing.hasOwnProperty(tmp)) {
            // generating data for the template
            mustachio.mustacheTagHandlers.tagName = tmp;
            mustachio.mustacheTagHandlers.tagBaseName = tmp.replace(/^tags-/,'');
            // generating article template file.
            articleFile = mustachio.Mustache.to_html(mustachio.templates.tags, mustachio.mustacheTagHandlers, mustacheTemplateParts);
            fs.writeFileSync(path.join(art.dir, tmp), articleFile, 'utf8');
            // generating extended documentation html file.
            extendedDoc = '<p>TODO: Finish Documentation</p>';
            fs.writeFileSync(path.join(art.dir, '../extended_docs/tags/' + tmp), extendedDoc, 'utf8');
        }
    }
    console.log('Finished checking for missing tags articles.'.info);
    console.log('New articles found'.info + ' : ');
    console.dir(art.missing);
}

/**
 * Creates a command, suitable for the cmd.commandRegister.Asynchronous
 *  queue that will run Jsdoc on some place.
 * @param {Boolean} recurse Whether or not jsdoc should recurse.
 * @param {String} place Path appended to both the location of
 *  jsdoc and the documentation project.
 * @param {Function} callback A callback function to execute when
 *  jsdoc3_commandlines.runJsdocOn has completed.
 */
function createRunJsdocCommand(recurse, place) {
    var jsdocLocation, source, destination, configFileLoc;
    
    jsdocLocation = jsdocPaths.jsdocLocation;
    source = jsdocPaths.jsdocLocation + '/' + place;
    destination = jakeApiDirectories.jsdocRootOutputDir + '/' + place;
    configFileLoc = path.resolve(jsdocPaths.jsdocDocsLocation, 'Jake/confFiles/conf.json');
    
    return function (callback) {
        jsdoc3_commandlines.runJsdocOn(
            jsdocLocation,
            source,
            destination,
            recurse,
            configFileLoc,
            callback
        );
    };
}

/**
 * Function for rebuilding the describe tags data.
 * @function 
 * @param {Function} callback A callback function to execute when
 *  the task completes.
 */
function rebuildDescribeTags(callback) {
    var jsdocLocation, destination;
    jsdocLocation = jsdocPaths.jsdocLocation;
    destination   = jakeApiDirectories.describeTagsOutputDir;
    
    jsdoc3_commandlines.rebuildDescribeTags(jsdocLocation, destination, callback);
}

/**
 * Gets the commandline options from JSDoc 3 and writes them
 *  to a file.
 * @function
 * @param {Function} callback A callback function to execute when
 *  the task completes.
 */
function getCommandlineOptions(callback) {
    var jsdocLocation, where, what;
    jsdocLocation = jsdocPaths.jsdocLocation;
    where = path.resolve(jakeApiDirectories.commandlineOptionsOutputDir, 'help');
    
    function writeCommandlineOptionsToFile(error, stdout, stderr) {
        fs.writeFile(where, String(stdout), 'utf8');
        callback();
    }
    jsdoc3_commandlines.getCommandlineOptions(jsdocLocation, writeCommandlineOptionsToFile);
}

/**
 * Function to run jake's default action.
 * @function 
 * @param {Function} callback A callback function to execute when
 *  the task completes.
 */
function runJake(callback) {
    var jakeLocation, jakeFile;
    jakeLocation = jsdocPaths.jsdocDocsLocation;
    jakeFile = 'jakefile.js';
    jsdoc3_commandlines.runJake(jakeFile, jakeLocation, callback);
}

jsdocPaths = verifyJsdocPathsAndFiles();

jakeApiDirectories = {
    'describeTagsOutputDir'       : path.resolve(jsdocPaths.jsdocDocsLocation, 'Jake/API/describeTags'),
    'jsdocRootOutputDir'          : path.resolve(jsdocPaths.jsdocDocsLocation, 'Jake/API/jsdoc'),
    'commandlineOptionsOutputDir' : path.resolve(jsdocPaths.jsdocDocsLocation, 'Jake/API/help')
};

exports.jsdocPaths                  = jsdocPaths;
exports.jakeApiDirectories          = jakeApiDirectories;
exports.verifyJsdocPathsAndFiles    = verifyJsdocPathsAndFiles;
exports.generateMissingTagsArticles = generateMissingTagsArticles;
exports.createRunJsdocCommand       = createRunJsdocCommand;
exports.rebuildDescribeTags         = rebuildDescribeTags;
exports.getCommandlineOptions       = getCommandlineOptions;
exports.runJake                     = runJake;
exports.colors                      = colors;
