/*jslint indent: 4, maxerr: 50, white: true, node: true, stupid: true */

/**
 * @file This file contains code to regenerate the api documentation for
 *  JSDoc 3 and merge it into the documentation website.
 * @author <a href="matthewkastor@gmail.com">Matthew Kastor</a>
 * @version 20121030
 * @requires events
 * @requires util
 * @requires cmd
 * @requires jsdoc3_utilities
 * @exports Jsdoc3_api_generator
 */

'use strict';

var util, events;

util   = require('util');
events = require('events');


/**
 * Class containing the functions and data necessary for
 * regenerating the API data to JSDoc 3.
 * @author <a href="matthewkastor@gmail.com">Matthew Kastor</a>
 * @class
 * @requires events
 * @requires util
 * @requires cmd
 * @requires jsdoc3_utilities
 */
function Jsdoc3_api_generator() {
    var cmd,
        jsdoc3_utilities;
    
    cmd              = require('cmd');
    jsdoc3_utilities = require('jsdoc3_utilities');
    
    events.EventEmitter.call(this);

    this.on('error',
        function(err) {
            console.log(err);
            process.exit(1);
        }
    );
    
    /**
     * Calls jsdoc --describeTags htmlFiles -d <jsdoc3.github.com> to
     *  update the tags definition files. Generates API documentation from 
     *  JSDoc 3. Then either calls jake to rebuild the docs or calls the callback.
     * @param {Function} callback If supplied, this will execute aget API docs
     *  have been generated. Otherwise, the default jake task will be run.
     */
    this.generateDocs = function generateDocs(callback) {
        callback = callback || false;
        var syncReg, asyncReg, places, recurse;
        
        syncReg = new cmd.commandRegister.Synchronous('sync');
        asyncReg = new cmd.commandRegister.Asynchronous('async');
        
        syncReg.on('command queue processed', function (name) {
            console.log('sync register ' + name + ' has finished');
            callback();
        });
        
        asyncReg.on('command queue processed', function (name) {
            console.log('async register ' + name + ' has finished');
            syncReg.process();
        });
        
        if(callback) {
            syncReg.queue = [
                jsdoc3_utilities.rebuildDescribeTags
            ];
        } else {
            syncReg.queue = [
                jsdoc3_utilities.rebuildDescribeTags,
                jsdoc3_utilities.runJake
            ];
        }
        
        places = [
            'rhino_modules',
            'templates',
            'plugins',
            'node_modules',
            'jsdoc.js'
        ];
        
        places.forEach(function(place) {
            if(place === 'jsdoc.js') {
                recurse = false;
            } else {
                recurse = true;
            }
            asyncReg.queue.unshift(
                jsdoc3_utilities.createRunJsdocCommand(recurse, place)
            );
        });
        
        asyncReg.process();
        
    };
    
}
util.inherits(Jsdoc3_api_generator, events.EventEmitter);

exports.Jsdoc3_api_generator = Jsdoc3_api_generator;
